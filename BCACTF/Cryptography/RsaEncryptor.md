# Description
I made an rsa encrypter to send my messages but it seems to be inconsistent...
# Resources
Server.py
```
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes


message = open("./flag.txt").read().encode('utf-8')  


def encode():
    n = getPrime(512)*getPrime(512)
    ciphertext = pow(bytes_to_long(message), 3, n)
    return (ciphertext, n)

print("Return format: (ciphertext, modulus)")
print(encode())
sent = input("Did you recieve the message? (y/n) ")
while sent=='n':
    print(encode())
    sent = input("How about now? (y/n) ")
print("Message acknowledged.")
```
# Hints
Search up Chinese Remainder Theorem
# Solution
Analyzing the code, you get three different modulus but are all coprime with each other which means a simple chinese remainder theorem code will do the work.

I will first acquire atleast 3 pairs of modulus and ciphertext to make this work in nc challs.bcactf.com 31452.

Code:
```
from Crypto.Util.number import long_to_bytes
import gmpy2

def egcd(a, b):
    x, y, u, v = 0, 1, 1, 0
    while a != 0:
        q, r = b // a, b % a
        m, n = x - u * q, y - v * q
        b, a, x, y, u, v = a, r, u, v, m, n
    gcd = b
    return gcd, x, y

def mod_inv(a, m):
    """Find the modular inverse using the Extended Euclidean Algorithm"""
    gcd, x, _ = egcd(a, m)
    if gcd != 1:
        raise ValueError(f"No modular inverse for {a} mod {m}")
    return x % m

#Given values
m1 = 129236425288969330202436190792086476145504572071978292393371067858391602007835451142189991220576366276084381902909027753326848241586272825791601317893426557098434537822150757513714142840586602339890626601222893083749618456651467551294858626648418006178323668615355540013482799307454492515747273465759927750347
m2 = 89779187785435999845883656398217616165136023187289141060206595691977241149097798242417871777522579289473535939677518972031038820984138122647580617293811737651684354797068805094417754482433925924781783672770874927964542623858454052441358289672896410708575449716719454560602944210349282431756739834077874342871
m3 = 129520037312575752395700243582964989022744863380757256245345597825218436282752879924280998633048340317637963738116473514666195768216368072182655537523337030988579286578016307093886407888306696184499309743494445809704101390453633979656441022367454348273748141660762124011383834250595113851289881182291037230841

a1 = 75860311851203490978199907597849173409273330054860989670507914140648879725405211623990589423684461001144935680704732424228174107554134977123475644288328325974683242357253413129197200485659913618143471912407132815335501208001156952403405857044922232362810448612394060598611981038561561369418071474627746222683
a2 = 53521495084609739989055078273147298503678787652767422245664356006692989133979915168120910030042816460033853676653970787224997592950364636387335200455570525967880949458327340803623222880923292515825668555270277051584244976179259496114826196311831859630864219269674749757379248122387290870712315167811908764786
a3 = 828530810036535758075371359701663772516564515884144542709291569551980207477945515461051024776602673670333202712765651742820400613621254445587617996439875794022375697192222971437650798495679082570028686669562595973330260833263800254371932997583037388695476825602275901340180228556781023502427161931205417841

# Calculate M
M = m1 * m2 * m3

# Calculate partial products
M1 = M // m1
M2 = M // m2
M3 = M // m3

# Calculate modular inverses
M1_inv = mod_inv(M1, m1)
M2_inv = mod_inv(M2, m2)
M3_inv = mod_inv(M3, m3)

# Combine using CRT
x = (a1 * M1 * M1_inv + a2 * M2 * M2_inv + a3 * M3 * M3_inv) % M
print(x)
# Convert the result to bytes
result = long_to_bytes(gmpy2.iroot(x,3)[0])
print(result)
```
# Flag
bcactf{those_were_some_rather_large_numbersosvhb9wrp8ghed}
